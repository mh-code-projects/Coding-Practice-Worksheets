// =======================================================
// Section 1: Reference — Quick Guide for Callbacks
// =======================================================

// CALLBACK DEFINITION:
// A callback is a function that is passed as an argument into another function,
// and then invoked ("called back") later inside that function.

// WHY CALLBACKS EXIST:
// - Control execution order
// - Customize behavior without rewriting logic
// - Handle asynchronous operations (timers, events, data loading)

// BASIC SYNTAX:
function doSomething(callback) {
  callback();
}

// CALLBACK WITH PARAMETERS:
function processValue(value, callback) {
  callback(value);
}

// CALLBACK USED FOR FLEXIBLE BEHAVIOR:
function calculate(a, b, operation) {
  operation(a, b);
}

// ASYNCHRONOUS CALLBACK EXAMPLE (TIMERS):
setTimeout(function () {
  // runs later
}, 1000);

// KEY MENTAL MODEL:
// "I don’t know *what* will happen yet — I just know *when* to run it."


// =======================================================
// Section 2: Sample Data (used throughout the worksheet)
// =======================================================

let numbers = [2, 4, 6, 8, 10];
let users = [
  { name: "Alex", age: 30 },
  { name: "Jordan", age: 22 },
  { name: "Sam", age: 40 }
];


// =======================================================
// Section 3: Challenge Prompts
// =======================================================

// -------------------------------------------------------
// Challenge 1: Callback Fundamentals
// -------------------------------------------------------
// Create a function that accepts another function as an argument.
// Inside the outer function, invoke the callback.
// Purpose: Build comfort passing and executing functions dynamically.

function functionA(functionB){
  functionB();
}

// -------------------------------------------------------
// Challenge 2: Callbacks with Data
// -------------------------------------------------------
// Create a function that accepts a value and a callback.
// Inside the function, pass the value into the callback when calling it.
// Purpose: Understand how callbacks receive and act on data.

function functionC(repeatTimes, functionD){
    functionD(repeatTimes);
  }


// -------------------------------------------------------
// Challenge 3: Custom Behavior with Callbacks
// -------------------------------------------------------
// Create a function that accepts two numbers and a callback.
// The callback should determine how the two numbers are handled.
// Purpose: See how callbacks allow flexible logic without rewriting functions.


// -------------------------------------------------------
// Challenge 4: Iteration Using Callbacks
// -------------------------------------------------------
// Create a function that loops over the `numbers` array.
// For each number, invoke a callback and pass the current number into it.
// Purpose: Learn how callbacks are used to customize behavior during iteration.


// -------------------------------------------------------
// Challenge 5: Conditional Logic via Callbacks
// -------------------------------------------------------
// Create a function that accepts a user object and two callbacks.
// One callback should run if the user meets a condition you define,
// and the other callback should run if they do not.
// Purpose: Use callbacks to decouple decision-making from action.


// -------------------------------------------------------
// Challenge 6: Asynchronous Callback Simulation
// -------------------------------------------------------
// Create a function that uses setTimeout internally.
// After a delay, invoke a callback passed into the function.
// Purpose: Understand why callbacks are critical for async operations.


// -------------------------------------------------------
// Challenge 7: Building a Reusable Processor (Multi-Step)
// -------------------------------------------------------
// A) Create a function that accepts an array and a callback.
// B) Loop through the array and pass each element into the callback.
// C) Reuse this function with different callbacks to perform different actions.
// Purpose: See how callbacks enable powerful abstraction and reuse.


// -------------------------------------------------------
// Challenge 8: Callback Composition
// -------------------------------------------------------
// Create a function that accepts a value and a callback.
// The callback itself should accept another callback.
// Purpose: Train your mental model for nested callbacks and execution flow.


// =======================================================
// End Goal Reflection (mental exercise — no code required)
// =======================================================
// Identify places where callbacks:
// - Remove duplication
// - Delay execution
// - Allow interchangeable logic
// - Separate "what happens" from "when it happens"
